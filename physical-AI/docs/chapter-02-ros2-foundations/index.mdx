---
title: Robotics Foundations with ROS 2
slug: /ros2-foundations   # ensures unique URL
sidebar_label: ROS 2 Foundations
sidebar_position: 2
---

## Learning Outcomes

Upon completing this chapter, you will be able to:

*   Understand the core architecture and components of ROS 2.
*   Set up a ROS 2 development workspace.
*   Implement basic ROS 2 applications using nodes, topics, services, and actions.
*   Utilize ROS 2 command-line tools for introspection and management.
*   Write simple ROS 2 programs in Python and C++.

---

## ROS 2 Architecture Overview

ROS 2 (Robot Operating System 2) is a flexible framework for writing robot software. It's not an operating system in the traditional sense, but a collection of tools, libraries, and conventions that simplify the task of creating complex and robust robot applications. ROS 2 is designed to be more robust, secure, and production-ready than its predecessor, ROS 1, addressing the needs of industrial and research applications.

Key architectural aspects of ROS 2 include:

*   **Decentralized Communication**: Unlike ROS 1's central master, ROS 2 uses DDS (Data Distribution Service) as its middleware, enabling direct peer-to-peer communication between nodes. This enhances reliability and performance.
*   **Nodes**: The fundamental building blocks of ROS 2 applications. Each node is an executable process that performs a specific task (e.g., controlling a motor, processing sensor data, planning a path).
*   **Topics**: The primary mechanism for asynchronous, many-to-many data streaming. Nodes publish messages to topics, and other nodes subscribe to those topics to receive data.
*   **Services**: Used for synchronous, request-response communication between nodes. A client sends a request to a service, and the service performs a task and sends back a response.
*   **Actions**: Provide long-running, goal-oriented communication. An action client sends a goal, receives continuous feedback, and eventually a result, suitable for tasks like navigating to a location or grasping an object.
*   **Parameters**: Allow dynamic configuration of nodes at runtime. Nodes can declare parameters, and their values can be read and set by other nodes or command-line tools.
*   **Launch Files**: XML or Python files used to start and configure multiple ROS 2 nodes and other processes simultaneously, simplifying system deployment.
*   **Packages**: The organizational unit for ROS 2 code, containing nodes, libraries, configuration files, and build instructions.

## Setting up a ROS 2 Workspace

A ROS 2 workspace is a directory where you organize your ROS 2 packages. It typically contains `src` (source code), `build` (build artifacts), `install` (installed packages), and `log` directories.

### Prerequisites

Before setting up a workspace, ensure you have a compatible ROS 2 distribution installed (e.g., Foxy, Galactic, Humble). This book will primarily use **ROS 2 Humble** running on Ubuntu 22.04 LTS.

### Steps to Create a Workspace

1.  **Create the workspace directory**:
    ```bash
    mkdir -p ~/ros2_ws/src
    cd ~/ros2_ws
    ```
2.  **Initialize `colcon` workspace**:
    `colcon` is the build tool used in ROS 2.
    ```bash
    colcon build
    ```
    This command will create `build`, `install`, and `log` directories.
3.  **Source the setup files**: To use the ROS 2 commands and packages, you need to source the setup file from your installed ROS 2 distribution and then from your workspace.
    ```bash
    # Source your ROS 2 installation (e.g., Humble)
    source /opt/ros/humble/setup.bash
    # Source your workspace (must be done after ROS 2 installation source)
    source install/setup.bash
    ```
    It's recommended to add these `source` commands to your `~/.bashrc` file for convenience:
    ```bash
    echo "source /opt/ros/humble/setup.bash" >> ~/.bashrc
    echo "source ~/ros2_ws/install/setup.bash" >> ~/.bashrc
    exec bash
    ```

## Nodes, Topics, and Messages

### Nodes

As mentioned, nodes are executable processes. In ROS 2, you might have a node for reading lidar data, another for controlling robot wheels, and another for path planning. Each node focuses on a single, well-defined task.

### Topics

Topics are the backbone of data flow in ROS 2. They are named buses over which nodes exchange messages. Messages are simply data structures. ROS 2 provides standard message types, but you can also define custom ones.

**Example**: A camera node might publish `sensor_msgs/msg/Image` messages to a topic named `/camera/image_raw`. A vision processing node would subscribe to this topic to receive images.

### Messages

Messages are strictly typed data structures used for communication over topics. They are defined using `.msg` files, which specify the fields and their types (e.g., `std_msgs/msg/String`, `geometry_msgs/msg/Twist`).

## Services and Actions

### Services

Services enable synchronous communication where a client sends a request and waits for a response from a server. This is suitable for tasks that complete quickly and require a definitive result.

**Example**: A client might request a `MoveRobot` service to move a robot to a specific coordinate. The service server would move the robot and return a `Success` or `Failure` status.

### Actions

Actions are built on topics and services, providing a more complex, asynchronous, and goal-oriented communication pattern. They are ideal for long-running tasks that provide continuous feedback during execution and a final result upon completion.

**Components of an Action**: A goal (what to achieve), feedback (progress updates), and a result (outcome).

**Example**: A `NavigateToWaypoint` action. The client sends a waypoint goal. The action server provides feedback (current position, distance to goal) as the robot moves and finally sends a result (reached, failed).

## Parameter Server

ROS 2 parameters allow nodes to expose configurable values. These values can be changed dynamically without recompiling the node, making applications more flexible.

**Example**: A robot's navigation node might have parameters for `max_speed` or `obstacle_threshold`. These can be adjusted at runtime to fine-tune behavior.

### Declaring and Using Parameters

Nodes typically declare parameters in their constructor and then retrieve their values. Parameters can be of various types (integer, float, string, boolean).

## `ros2 run` and `ros2 launch`

### `ros2 run`

Used to execute a single ROS 2 executable (a node) from an installed package.

**Syntax**: `ros2 run <package_name> <executable_name>`

**Example**: `ros2 run demo_nodes_py talker` (runs a Python talker node from `demo_nodes_py` package).

### `ros2 launch`

Used to start multiple ROS 2 nodes and configure their parameters, typically defined in a `.launch.py` (Python) or `.launch.xml` (XML) file. This is crucial for deploying complex robotic systems.

**Syntax**: `ros2 launch <package_name> <launch_file_name>`

**Example**: `ros2 launch nav2_bringup navigation_launch.py` (launches the Nav2 navigation stack).

## Basic ROS 2 Python/C++ Programming

This section will provide a high-level overview. Detailed code examples will be in the labs.

### Python (`rclpy`)

Writing a simple publisher node in Python:

```python
import rclpy
from rclpy.node import Node
from std_msgs.msg import String

class MinimalPublisher(Node):

    def __init__(self):
        super().__init__('minimal_publisher')
        self.publisher_ = self.create_publisher(String, 'topic', 10)
        timer_period = 0.5  # seconds
        self.timer = self.create_timer(timer_period, self.timer_callback)
        self.i = 0

    def timer_callback(self):
        msg = String()
        msg.data = 'Hello ROS 2: %d' % self.i
        self.publisher_.publish(msg)
        self.get_logger().info('Publishing: "%s"' % msg.data)
        self.i += 1

def main(args=None):
    rclpy.init(args=args)

    minimal_publisher = MinimalPublisher()

    rclpy.spin(minimal_publisher)

    minimal_publisher.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

### C++ (`rclcpp`)

Writing a simple publisher node in C++:

```cpp
#include <chrono>
#include <memory>

#include "rclcpp/rclcpp.hpp"
#include "std_msgs/msg/string.hpp"

using namespace std::chrono_literals;

class MinimalPublisher : public rclcpp::Node
{
public:
  MinimalPublisher()
  : Node("minimal_publisher"), count_(0)
  {
    publisher_ = this->create_publisher<std_msgs::msg::String>("topic", 10);
    timer_ = this->create_wall_timer(
      500ms, std::bind(&MinimalPublisher::timer_callback, this));
  }

private:
  void timer_callback()
  {
    auto message = std_msgs::msg::String();
    message.data = "Hello ROS 2: " + std::to_string(count_++);
    RCLCPP_INFO(this->get_logger(), "Publishing: '%s'", message.data.c_str());
    publisher_->publish(message);
  }
  rclcpp::TimerBase::SharedPtr timer_;
  rclcpp::Publisher<std_msgs::msg::String>::SharedPtr publisher_;
  size_t count_;
};

int main(int argc, char * argv[])
{
  rclcpp::init(argc, argv);
  rclcpp::spin(std::make_shared<MinimalPublisher>());
  rclcpp::shutdown();
  return 0;
}
```

## Further Reading and Exercises

*   **Explore**: Dive deeper into the official ROS 2 documentation for your chosen distribution.
*   **Implement**: Try modifying the basic publisher example to publish different message types or at different frequencies.
*   **Experiment**: Create a simple subscriber node that receives messages from your publisher node.

---

### Key Takeaways for the Capstone Project

This chapter has provided the foundational knowledge of ROS 2, which will be critical for our capstone humanoid. We will use ROS 2 for:

*   **Inter-component Communication**: Nodes for perception, language, and action will communicate via ROS 2 topics and services.
*   **Robot Control**: Sending commands to the simulated humanoid (e.g., joint commands, navigation goals) using ROS 2 interfaces.
*   **System Integration**: Launching and managing the entire complex system using ROS 2 launch files.
*   **Data Streaming**: Handling sensor data (e.g., camera feeds, IMU data) through ROS 2 topics.

As we progress, we will apply these ROS 2 concepts to integrate the various intelligent modules of our humanoid AI system.