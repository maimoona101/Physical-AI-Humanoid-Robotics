---
id: "lab-gazebo-model"
title: "Lab: Gazebo Model and Basic Control"
sidebar_label: "Lab: Gazebo Model"
sidebar_position: 1
---

## Introduction

This lab will guide you through the fundamental steps of setting up a ROS 2 development environment and implementing basic communication patterns: a publisher, a subscriber, and a simple teleoperation example. By the end of this lab, you will be able to create your own ROS 2 nodes and understand how they communicate using topics.

## Prerequisites

*   An installed ROS 2 Humble distribution (preferably on Ubuntu 22.04 LTS).
*   A basic understanding of Python programming.
*   Familiarity with the Linux command line.

## Part 1: Setting up Your ROS 2 Workspace

If you haven't already, set up your ROS 2 workspace as described in Chapter 2.

1.  **Create the workspace directory**:
    ```bash
    mkdir -p ~/ros2_ws/src
    cd ~/ros2_ws
    ```
2.  **Initialize `colcon` workspace and build** (if this is the first time):
    ```bash
    colcon build
    ```
3.  **Source the setup files**: Add these to your `~/.bashrc` for convenience.
    ```bash
    echo "source /opt/ros/humble/setup.bash" >> ~/.bashrc
    echo "source ~/ros2_ws/install/setup.bash" >> ~/.bashrc
    exec bash
    ```

## Part 2: Creating a Simple ROS 2 Package

We will create a new package to house our publisher and subscriber nodes.

1.  **Navigate to your workspace source directory**:
    ```bash
    cd ~/ros2_ws/src
    ```
2.  **Create a new Python package `my_ros2_pkg`**:
    ```bash
    ros2 pkg create --build-type ament_python my_ros2_pkg
    ```
    This creates a directory `my_ros2_pkg` with a basic structure, including `setup.py` and `package.xml`.

## Part 3: Implementing a Minimal Publisher Node

We will create a Python node that publishes a "Hello World" message to a topic.

1.  **Create `publisher_node.py`** in `~/ros2_ws/src/my_ros2_pkg/my_ros2_pkg/`:
    ```python
    # ~/ros2_ws/src/my_ros2_pkg/my_ros2_pkg/publisher_node.py

    import rclpy
    from rclpy.node import Node
    from std_msgs.msg import String

    class MinimalPublisher(Node):

        def __init__(self):
            super().__init__('minimal_publisher')
            self.publisher_ = self.create_publisher(String, 'chatter', 10)
            timer_period = 0.5  # seconds
            self.timer = self.create_timer(timer_period, self.timer_callback)
            self.i = 0

        def timer_callback(self):
            msg = String()
            msg.data = f'Hello ROS 2: {self.i}'
            self.publisher_.publish(msg)
            self.get_logger().info(f'Publishing: "{msg.data}"')
            self.i += 1

    def main(args=None):
        rclpy.init(args=args)
        minimal_publisher = MinimalPublisher()
        rclpy.spin(minimal_publisher)
        minimal_publisher.destroy_node()
        rclpy.shutdown()

    if __name__ == '__main__':
        main()
    ```
2.  **Make the script executable**:
    ```bash
    chmod +x ~/ros2_ws/src/my_ros2_pkg/my_ros2_pkg/publisher_node.py
    ```
3.  **Update `setup.py`**: Add an entry point for your new executable.
    Edit `~/ros2_ws/src/my_ros2_pkg/setup.py` and add `'minimal_publisher = my_ros2_pkg.publisher_node:main'` to the `entry_points` dictionary. It should look like this:
    ```python
    from setuptools import setup

    package_name = 'my_ros2_pkg'

    setup(
        name=package_name,
        version='0.0.0',
        packages=[package_name],
        data_files=[
            ('share/' + package_name, ['package.xml']),
            ('share/' + package_name + '/resource', ['%s.egg-info' % package_name]),
        ],
        install_requires=['setuptools'],
        zip_safe=True,
        maintainer='your_name',
        maintainer_email='your_email@example.com',
        description='TODO: Package description',
        license='TODO: License declaration',
        tests_require=['pytest'],
        entry_points={
            'console_scripts': [
                'minimal_publisher = my_ros2_pkg.publisher_node:main',
            ],
        },
    )
    ```
4.  **Build your package**:
    Navigate to your workspace root and build.
    ```bash
    cd ~/ros2_ws
    colcon build --packages-select my_ros2_pkg
    ```
5.  **Source your workspace again** (after building new packages):
    ```bash
    source install/setup.bash
    ```
6.  **Run your publisher node**:
    ```bash
    ros2 run my_ros2_pkg minimal_publisher
    ```
    You should see messages being published in your terminal.

## Part 4: Implementing a Minimal Subscriber Node

Now, let's create a node that subscribes to the `chatter` topic and prints the messages it receives.

1.  **Create `subscriber_node.py`** in `~/ros2_ws/src/my_ros2_pkg/my_ros2_pkg/`:
    ```python
    # ~/ros2_ws/src/my_ros2_pkg/my_ros2_pkg/subscriber_node.py

    import rclpy
    from rclpy.node import Node
    from std_msgs.msg import String

    class MinimalSubscriber(Node):

        def __init__(self):
            super().__init__('minimal_subscriber')
            self.subscription = self.create_subscription(
                String,
                'chatter',
                self.listener_callback,
                10)
            self.subscription  # prevent unused variable warning

        def listener_callback(self, msg):
            self.get_logger().info(f'I heard: "{msg.data}"')

    def main(args=None):
        rclpy.init(args=args)
        minimal_subscriber = MinimalSubscriber()
        rclpy.spin(minimal_subscriber)
        minimal_subscriber.destroy_node()
        rclpy.shutdown()

    if __name__ == '__main__':
        main()
    ```
2.  **Make the script executable**:
    ```bash
    chmod +x ~/ros2_ws/src/my_ros2_pkg/my_ros2_pkg/subscriber_node.py
    ```
3.  **Update `setup.py`**: Add an entry point for the subscriber.
    Edit `~/ros2_ws/src/my_ros2_pkg/setup.py` and add `'minimal_subscriber = my_ros2_pkg.subscriber_node:main'` to the `entry_points` dictionary, alongside the publisher entry point:
    ```python
    # ...
        entry_points={
            'console_scripts': [
                'minimal_publisher = my_ros2_pkg.publisher_node:main',
                'minimal_subscriber = my_ros2_pkg.subscriber_node:main',
            ],
        },
    )
    ```
4.  **Rebuild your package**:
    ```bash
    cd ~/ros2_ws
    colcon build --packages-select my_ros2_pkg
    source install/setup.bash
    ```
5.  **Run the nodes (in separate terminals)**:
    *   Terminal 1 (Publisher):
        ```bash
        ros2 run my_ros2_pkg minimal_publisher
        ```
    *   Terminal 2 (Subscriber):
        ```bash
        ros2 run my_ros2_pkg minimal_subscriber
        ```
    You should see the subscriber terminal printing the messages published by the publisher.

## Part 5: Simple Teleoperation with `teleop_twist_keyboard`

For controlling a robot, often `geometry_msgs/msg/Twist` messages are used for linear and angular velocity commands. ROS 2 provides a handy package for keyboard-based teleoperation.

1.  **Install `teleop_twist_keyboard`** (if not already installed with your ROS 2 distribution):
    ```bash
    sudo apt update
    sudo apt install ros-humble-teleop-twist-keyboard
    ```
2.  **Run the teleop node**:
    ```bash
    ros2 run teleop_twist_keyboard teleop_twist_keyboard
    ```
    Follow the instructions in the terminal. You can use your keyboard to publish `geometry_msgs/msg/Twist` messages to the `/cmd_vel` topic.
3.  **Observe the messages** (optional, in a third terminal):
    ```bash
    ros2 topic echo /cmd_vel
    ```
    This will show you the `Twist` messages being published as you press keys.

## Summary

In this lab, you successfully set up a ROS 2 workspace, created a custom package, implemented publisher and subscriber nodes to communicate via topics, and explored basic teleoperation. These foundational skills are essential for developing more complex robotic applications.

## Further Exploration

*   **Create a custom message type**: Define your own `.msg` file and use it in publisher/subscriber nodes.
*   **Implement a simple service**: Create a client and server for a custom service.
*   **Experiment with `ros2 launch`**: Create a launch file to start your publisher and subscriber nodes simultaneously.

---

### Capstone Project Relevance

The concepts learned here are directly applicable to the Capstone Project:

*   Your humanoid robot will have **nodes** for various functions (perception, control, language processing).
*   These nodes will communicate using **topics** to exchange sensor data, processed information, and commands.
*   **Teleoperation** principles can be extended to manually control the humanoid for debugging or specific tasks, using `Twist` messages or more complex joint commands.
*   The workspace setup and package creation process will be the basis for organizing all capstone code.
